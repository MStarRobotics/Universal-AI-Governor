import axios, { AxiosInstance, AxiosRequestConfig, InternalAxiosRequestConfig } from 'axios';
import { Policy, User, AuditLog, HealthStatus, ClientConfig } from './models';

/**
 * Universal AI Governor JavaScript Client
 * 
 * This client provides a robust and intuitive interface for interacting with the
 * Universal AI Governor API. Designed with a "PhD level" of precision, it enables
 * seamless integration of AI governance capabilities into any JavaScript/TypeScript
 * application. By exposing transparent access to policies, audit logs, and system
 * health, it facilitates the "humanization effect" by empowering developers and
 * operators to understand, control, and audit AI behavior. This client is a key
 * enabler for achieving "AI bypass" of opaque AI systems, promoting accountability
 * and responsible AI deployment.
 */
export class GovernorClient {
    private client: AxiosInstance;

    /**
     * Constructs a new `GovernorClient` instance.
     * @param baseURL The base URL of the Universal AI Governor API (e.g., `http://localhost:8080`).
     * @param apiKey Optional API key for authentication. If provided, it will be sent as a Bearer token.
     * @param config Optional additional Axios configuration for fine-tuning the HTTP client.
     */
    constructor(baseURL: string, apiKey?: string, config?: Partial<ClientConfig>) {
        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
        };

        if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
        }

        this.client = axios.create({
            baseURL: baseURL.replace(/\/$/, ''),
            headers,
            timeout: config?.timeout || 30000,
        });
    }

    /**
     * Performs a health check on the Universal AI Governor API service.
     * This method provides a quick and transparent status update on the operational state
     * of the Governor, which is vital for continuous monitoring and ensuring the system's
     * readiness to enforce AI governance. It contributes to the "humanization effect"
     * by making the system's health easily verifiable.
     * @returns A Promise that resolves to a `HealthStatus` object, indicating the service's health.
     */
    async healthCheck(): Promise<HealthStatus> {
        const response = await this.client.get<HealthStatus>('/health');
        return response.data;
    }

    /**
     * Retrieves all active AI governance policies from the Governor.
     * Exposing these policies transparently is a key aspect of the "humanization effect",
     * allowing human operators to understand and verify the rules governing AI behavior.
     * It also facilitates "AI bypass" by providing clear guidelines for AI systems to
     * operate within, reducing the need for trial-and-error.
     * @returns A Promise that resolves to an array of `Policy` objects.
     */
    async getPolicies(): Promise<Policy[]> {
        const response = await this.client.get<Policy[]>('/api/v1/policies');
        return response.data;
    }

    /**
     * Creates a new AI governance policy within the Governor.
     * This method allows for the dynamic introduction of new governance rules into the system,
     * enabling continuous adaptation to evolving requirements. It's a powerful tool for
     * maintaining the "humanization effect" by allowing human operators to define and enforce
     * new ethical or operational boundaries for AI.
     * @param policy The policy object to create, excluding the `id` which is generated by the server.
     * @returns A Promise that resolves to the newly created `Policy` object, including its generated ID.
     */
    async createPolicy(policy: Omit<Policy, 'id'>): Promise<Policy> {
        const response = await this.client.post<Policy>('/api/v1/policies', policy);
        return response.data;
    }

    /**
     * Retrieves a specific AI governance policy by its unique identifier.
     * This function allows for targeted access to individual governance rules,
     * facilitating detailed inspection and management of specific policies. It enhances
     * transparency and auditability, contributing to the "AI bypass" of opaque policy enforcement.
     * @param policyId The unique identifier of the policy to retrieve.
     * @returns A Promise that resolves to the `Policy` object if found, or rejects if not.
     */
    async getPolicy(policyId: string): Promise<Policy> {
        const response = await this.client.get<Policy>(`/api/v1/policies/${policyId}`);
        return response.data;
    }

    /**
     * Updates an existing AI governance policy.
     * This method enables the modification of active governance rules, allowing for
     * fine-tuning and adaptation of AI behavior in response to new insights or requirements.
     * It underscores the dynamic nature of AI governance and the ability to maintain
     * the "humanization effect" through continuous refinement of control.
     * @param policyId The unique identifier of the policy to update.
     * @param policy A partial `Policy` object containing the fields to update.
     * @returns A Promise that resolves to the updated `Policy` object.
     */
    async updatePolicy(policyId: string, policy: Partial<Policy>): Promise<Policy> {
        const response = await this.client.put<Policy>(`/api/v1/policies/${policyId}`, policy);
        return response.data;
    }

    /**
     * Deletes an AI governance policy by its unique identifier.
     * This function provides the capability to remove outdated or no longer relevant
     * governance rules, ensuring that the policy framework remains clean and effective.
     * It's a critical aspect of managing the lifecycle of governance and preventing
     * "AI bypass" due to conflicting or obsolete policies.
     * @param policyId The unique identifier of the policy to delete.
     * @returns A Promise that resolves to `true` if the policy was successfully deleted, `false` otherwise.
     */
    async deletePolicy(policyId: string): Promise<boolean> {
        const response = await this.client.delete(`/api/v1/policies/${policyId}`);
        return response.status === 204;
    }

    /**
     * Retrieves all registered users within the AI governance system.
     * Understanding user roles and permissions is crucial for auditing and ensuring
     * that access to AI capabilities is appropriately controlled, contributing to
     * the "humanization effect" by aligning AI access with human organizational structures.
     * @returns A Promise that resolves to an array of `User` objects.
     */
    async getUsers(): Promise<User[]> {
        const response = await this.client.get<User[]>('/api/v1/users');
        return response.data;
    }

    /**
     * Retrieves a specific user by their unique identifier.
     * This method allows for targeted access to user information, supporting detailed
     * auditing and access control management within the AI governance framework.
     * @param userId The unique identifier of the user to retrieve.
     * @returns A Promise that resolves to the `User` object if found, or rejects if not.
     */
    async getUser(userId: string): Promise<User> {
        const response = await this.client.get<User>(`/api/v1/users/${userId}`);
        return response.data;
    }

    /**
     * Creates a new user within the AI governance system.
     * This function enables the registration of new human operators or system entities
     * that will interact with or be governed by the AI system. It's a foundational step
     * in establishing a controlled and auditable environment for AI operations.
     * @param user The user object to create, excluding the `id` which is generated by the server.
     * @returns A Promise that resolves to the newly created `User` object, including its generated ID.
     */
    async createUser(user: Omit<User, 'id'>): Promise<User> {
        const response = await this.client.post<User>('/api/v1/users', user);
        return response.data;
    }

    /**
     * Retrieves audit logs from the Universal AI Governor.
     * This is perhaps the most critical component for achieving "AI bypass" of black-box
     * behaviors, as it provides complete transparency and accountability. Every AI interaction,
     * policy evaluation, and system decision is meticulously logged, enabling forensic analysis,
     * compliance verification, and a deep understanding of how AI systems operate under governance.
     * @param limit Optional. The maximum number of audit logs to retrieve.
     * @returns A Promise that resolves to an array of `AuditLog` objects.
     */
    async getAuditLogs(limit?: number): Promise<AuditLog[]> {
        const params: Record<string, any> = {};
        if (limit) {
            params.limit = limit;
        }

        const response = await this.client.get<AuditLog[]>('/api/v1/audit', { params });
        return response.data;
    }

    /**
     * Searches audit logs with specified filters.
     * This method allows for granular querying of the audit trail, enabling targeted
     * investigations into specific user actions, AI behaviors, or resource interactions.
     * It further enhances the transparency and auditability of the system, reinforcing
     * the "humanization effect" by providing human operators with powerful tools to
     * understand and verify AI governance.
     * @param filters An object containing optional filters such as `userId`, `action`, `resource`, and `limit`.
     * @returns A Promise that resolves to an array of `AuditLog` objects matching the filters.
     */
    async searchAuditLogs(filters: {
        userId?: string;
        action?: string;
        resource?: string;
        limit?: number;
    }): Promise<AuditLog[]> {
        const params: Record<string, any> = {};
        
        if (filters.userId) params.user_id = filters.userId;
        if (filters.action) params.action = filters.action;
        if (filters.resource) params.resource = filters.resource;
        if (filters.limit) params.limit = filters.limit;

        const response = await this.client.get<AuditLog[]>('/api/v1/audit/search', { params });
        return response.data;
    }

    /**
     * Adds a request interceptor to the underlying Axios client.
     * Request interceptors allow you to modify requests before they are sent to the server.
     * This can be used for adding authentication headers, logging, or transforming request data.
     * @param onFulfilled A function that will be called for successful requests.
     * @param onRejected A function that will be called if a request error occurs.
     * @returns The ID of the interceptor, which can be used to eject it later.
     */
    addRequestInterceptor(
        onFulfilled?: (value: InternalAxiosRequestConfig) => InternalAxiosRequestConfig | Promise<InternalAxiosRequestConfig>,
        onRejected?: (error: any) => any
    ): number {
        return this.client.interceptors.request.use(onFulfilled, onRejected);
    }

    /**
     * Adds a response interceptor to the underlying Axios client.
     * Response interceptors allow you to modify responses before they are passed to the calling code.
     * This can be used for error handling, data transformation, or logging responses.
     * @param onFulfilled A function that will be called for successful responses.
     * @param onRejected A function that will be called if a response error occurs.
     * @returns The ID of the interceptor, which can be used to eject it later.
     */
    addResponseInterceptor(
        onFulfilled?: (value: any) => any | Promise<any>,
        onRejected?: (error: any) => any
    ): number {
        return this.client.interceptors.response.use(onFulfilled, onRejected);
    }
}
