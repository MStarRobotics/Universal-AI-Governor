[package]
name = "universal-ai-governor"
version = "1.0.0"
edition = "2021"
authors = ["Sourav Rajak <morningstar.xcd@gmail.com>"]
description = "Hardware-backed AI governance platform for enterprise deployments"
license = "MIT"
repository = "https://github.com/morningstarxcdcode/universal-ai-governor"
homepage = "https://github.com/morningstarxcdcode/universal-ai-governor"
documentation = "https://docs.rs/universal-ai-governor"
readme = "README.md"
keywords = ["ai", "security", "governance", "tpm", "enterprise"]
categories = ["security", "web-programming", "api-bindings"]

# I'm being pretty conservative with the MSRV here, but 1.70 has all the features I need
rust-version = "1.70"

[dependencies]
# Core async runtime - tokio is pretty much the standard at this point
tokio = { version = "1.0", features = ["full"] }

# Web framework - I chose axum because it's fast and has good ergonomics
axum = { version = "0.7", features = ["macros", "multipart"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace", "compression"] }

# Serialization - serde is the obvious choice
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# Configuration management
config = "0.14"
clap = { version = "4.0", features = ["derive"] }

# Logging and tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# Error handling
thiserror = "1.0"
anyhow = "1.0"

# Cryptography - ring is fast and well-audited
ring = "0.17"
zeroize = { version = "1.7", features = ["derive"] }

# Database support
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite", "postgres", "chrono", "uuid"] }

# Caching
redis = { version = "0.24", features = ["tokio-comp"] }

# HTTP client for external integrations
reqwest = { version = "0.11", features = ["json", "rustls-tls"] }

# Time handling
chrono = { version = "0.4", features = ["serde"] }

# UUID generation
uuid = { version = "1.0", features = ["v4", "serde"] }

# JSON Web Tokens
jsonwebtoken = "9.0"

# Policy engine (Rego support)
# Note: This is a placeholder - we might need to implement our own Rego engine
# or find a better Rust implementation
rego = { version = "0.1", optional = true }

# Hardware security features (optional)
tss-esapi = { version = "7.0", optional = true }
pkcs11 = { version = "0.8", optional = true }

# Multimedia processing (optional)
opencv = { version = "0.88", optional = true }
image = { version = "0.24", optional = true }
symphonia = { version = "0.5", optional = true }

# AI/ML features (optional)
candle-core = { version = "0.3", optional = true }
candle-nn = { version = "0.3", optional = true }
candle-transformers = { version = "0.3", optional = true }

# Metrics and monitoring
prometheus = { version = "0.13", features = ["process"] }
opentelemetry = { version = "0.21", optional = true }
opentelemetry-jaeger = { version = "0.20", optional = true }

[dev-dependencies]
# Testing utilities
tokio-test = "0.4"
tempfile = "3.0"
wiremock = "0.5"

# Benchmarking
criterion = { version = "0.5", features = ["html_reports"] }

# Property-based testing
proptest = "1.0"

# Test utilities for async code
futures-util = "0.3"

[features]
default = ["sqlite", "redis-cache", "metrics"]

# Database backends
sqlite = ["sqlx/sqlite"]
postgres = ["sqlx/postgres"]

# Caching backends
redis-cache = ["redis"]

# Hardware security features
tpm-integration = ["tss-esapi"]
hsm-integration = ["pkcs11"]
hardware-security = ["tmp-integration", "hsm-integration"]

# AI and ML features
ai-policy-synthesis = ["candle-core", "candle-nn", "candle-transformers"]
multimedia-processing = ["opencv", "image", "symphonia"]

# Monitoring and observability
metrics = ["prometheus"]
tracing-jaeger = ["opentelemetry", "opentelemetry-jaeger"]

# All features (useful for development and testing)
all-features = [
    "postgres", "redis-cache", "hardware-security", 
    "ai-policy-synthesis", "multimedia-processing", 
    "metrics", "tracing-jaeger"
]

# Features for different deployment scenarios
minimal = ["sqlite"]
enterprise = ["postgres", "redis-cache", "hardware-security", "metrics"]
cloud = ["postgres", "redis-cache", "ai-policy-synthesis", "metrics", "tracing-jaeger"]

[[bin]]
name = "universal-ai-governor"
path = "src/main.rs"

[[bench]]
name = "policy_evaluation"
harness = false

[[bench]]
name = "crypto_operations"
harness = false

[[bench]]
name = "multimedia_processing"
harness = false
required-features = ["multimedia-processing"]

[[example]]
name = "basic_usage"
path = "examples/basic_usage.rs"

[[example]]
name = "hardware_integration"
path = "examples/hardware_integration.rs"
required-features = ["hardware-security"]

[[example]]
name = "ai_policy_synthesis"
path = "examples/ai_policy_synthesis.rs"
required-features = ["ai-policy-synthesis"]

[profile.release]
# Optimize for performance in release builds
opt-level = 3
lto = "fat"
codegen-units = 1
panic = "abort"

# Enable debug info for profiling even in release builds
debug = 1

[profile.dev]
# Faster compilation in development
opt-level = 0
debug = true
incremental = true

[profile.test]
# Optimize tests a bit for faster execution
opt-level = 1

[profile.bench]
# Maximum optimization for benchmarks
opt-level = 3
lto = "fat"
codegen-units = 1
debug = false

# Metadata for docs.rs
[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

# Configuration for cargo-deny
[package.metadata.cargo-deny]
# We're pretty strict about licenses
licenses = ["MIT", "Apache-2.0", "BSD-3-Clause"]
# And we want to know about security advisories
advisories = { db-path = "~/.cargo/advisory-db", db-urls = ["https://github.com/rustsec/advisory-db"] }
